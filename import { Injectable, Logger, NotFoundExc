import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { User } from '../user.entity';
import { Repository, DataSource } from 'typeorm';
import { CreateUserDto } from '../dto/create-user.dto';
import { UpdateUserDto } from '../dto/update-user.dto';
import { Portfolio } from '../../portfolio/entities/portfolio.entity';
import { Transaction } from '../../transactions/entities/transaction.entity';
import { UserHistoryFilterDto } from '../dto/user-history-filter.dto';

@Injectable()
export class UserService {
  private readonly logger = new Logger(UserService.name);

  constructor(
    @InjectRepository(User)
    private readonly usersRepository: Repository<User>,
    private readonly dataSource: DataSource,
  ) {}

  /**
   * Fetch a user's transaction/activity history with optional filters and stats summary
   */
  async getUserHistory(
    userId: number,
    filter: UserHistoryFilterDto,
  ): Promise<{ history: Transaction[]; stats: any }> {
    const portfolios = await this.dataSource.getRepository(Portfolio).find({
      where: { user: { id: userId } },
      relations: ['transactions', 'transactions.cryptocurrency'],
    });
    let transactions: Transaction[] = portfolios.flatMap((p) => p.transactions);
    if (filter.eventType) {
      transactions = transactions.filter((tx) => tx.type === filter.eventType);
    }
    if (filter.startDate) {
      const start = new Date(filter.startDate);
      transactions = transactions.filter((tx) => new Date(tx.timestamp) >= start);
    }
    if (filter.endDate) {
      const end = new Date(filter.endDate);
      transactions = transactions.filter((tx) => new Date(tx.timestamp) <= end);
    }
    const stats = {
      totalTrades: transactions.length,
      totalBuy: transactions.filter((tx) => tx.type === 'buy').length,
      totalSell: transactions.filter((tx) => tx.type === 'sell').length,
      totalAmountSwapped: transactions.reduce((sum, tx) => sum + Number(tx.amount), 0),
      assetsSwapped: Array.from(new Set(transactions.map((tx) => tx.cryptocurrency?.symbol))).filter(Boolean),
    };
    return { history: transactions, stats };
  }

  async create(createUserDto: CreateUserDto): Promise<User> {
    const user = this.usersRepository.create(createUserDto);
    const savedUser = await this.usersRepository.save(user);
    this.logger.log(`Created new user with id ${savedUser.id}`);
    return savedUser;
  }

  async findAll(): Promise<User[]> {
    this.logger.log(`Retrieving all users`);
    return this.usersRepository.find();
  }

  async findOne(id: number): Promise<User> {
    this.logger.log(`Finding user by id: ${id}`);
    const user = await this.usersRepository.findOne({ where: { id } });
    if (!user) {
      this.logger.warn(`User with id ${id} not found`);
      throw new NotFoundException(`User with id ${id} not found`);
    }
    return user;
  }

  async update(id: number, updateUserDto: UpdateUserDto): Promise<User> {
    this.logger.log(`Updating user with id: ${id}`);
    const user = await this.usersRepository.preload({
      id,
      ...updateUserDto,
    });
    if (!user) {
      this.logger.warn(`User with id ${id} not found`);
      throw new NotFoundException(`User with id ${id} not found`);
    }
    return this.usersRepository.save(user);
  }

  async remove(id: number): Promise<User> {
    this.logger.log(`Removing user with id: ${id}`);
    const user = await this.findOne(id);
    await this.usersRepository.remove(user);
    return user;
  }

  async findUserByEmail(email: string): Promise<User | null> {
    this.logger.log(`Finding user by email: ${email}`);
    return this.usersRepository.findOne({ where: { email } });
  }

  async updatePassword(userId: number, newPassword: string): Promise<void> {
    this.logger.log(`Updating password for user id: ${userId}`);
    await this.usersRepository.update(userId, { password: newPassword });
  }
}